const express = require('express');
const router = express.Router();
const axios = require('axios');
const cloudinary = require('cloudinary').v2;
const authMiddleware = require('../middlewares/authMiddleware');
require('dotenv').config();

// --- Configurations ---
const openaiApiKey = process.env.GEMINI_API_KEY;
const chatApiUrl = 'https://api.openai.com/v1/chat/completions';
const imageApiUrl = 'https://api.openai.com/v1/images/generations';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// =================================================================
// --- HELPER FUNCTIONS ---
// =================================================================

/**
 * Calls the image generation AI (DALL-E 3).
 */
const callImageAI = async (prompt) => {
  const response = await axios.post(
    imageApiUrl,
    {
      model: 'dall-e-3',
      prompt: prompt,
      n: 1,
      size: '1024x1024',
      quality: 'standard',
    },
    { headers: { 'Authorization': `Bearer ${openaiApiKey}`, 'Content-Type': 'application/json' } }
  );
  return response.data.data[0].url; // Returns the temporary image URL
};

/**
 * Uploads an image from a URL to Cloudinary.
 */
const uploadImageToCloudinary = async (imageUrl) => {
  try {
    const result = await cloudinary.uploader.upload(imageUrl, {
      folder: "post-generator-images", // Organizes images in a Cloudinary folder
    });
    return result.secure_url; // Returns the permanent HTTPS URL
  } catch (error) {
    console.error("Error uploading to Cloudinary:", error);
    throw new Error("Failed to upload image to Cloudinary.");
  }
};

/**
 * A specialized helper to get only hashtags for a specific platform.
 */
const callHashtagAI = async (platform, postContent) => {
  const currentYear = new Date().getFullYear();
  const prompt = `
    Based on the following social media post, generate a JSON object with a single key "hashtags".
    The value should be an array of 5-7 viral and trending hashtags tailored specifically for the ${platform} platform.
    Prefer up-to-date, currently trending tags. If you include year-specific tags, use ${currentYear}, not any past year.
    Avoid outdated or stale years (e.g., 2021/2022/2023/2024 when today is ${currentYear}).
    
    Post Content: """${postContent}"""
    
    Your final output must be only the JSON object.
  `;
  const response = await axios.post(chatApiUrl, {
    model: 'gpt-4o-mini',
    messages: [{ role: 'user', content: prompt }],
    response_format: { type: 'json_object' },
  }, { headers: { 'Authorization': `Bearer ${openaiApiKey}`, 'Content-Type': 'application/json' } });

  let result = JSON.parse(response.data.choices[0].message.content);
  // Data cleaning for hashtags
  const sanitizeHashtags = (list) => {
    const yearRegex = /(19|20)\d{2}/g;
    const targetYear = String(currentYear);
    const normalized = (list || [])
      .map(tag => tag?.toString()?.trim())
      .filter(Boolean)
      .map(tag => tag.startsWith('#') ? tag : `#${tag}`)
      .map(tag => tag.replace(yearRegex, targetYear))
      .map(tag => tag.replace(/\s+/g, ''));
    // Ensure uniqueness while preserving order
    const seen = new Set();
    const unique = [];
    for (const tag of normalized) {
      const lower = tag.toLowerCase();
      if (!seen.has(lower)) {
        seen.add(lower);
        unique.push(tag);
      }
    }
    return unique;
  };

  if (result.hashtags && typeof result.hashtags === 'string') {
    result.hashtags = result.hashtags.split(',');
  }
  result.hashtags = sanitizeHashtags(result.hashtags);
  return result;
};

/**
 * Generate a platform-specific caption and hashtags from a universal postContent.
 */
const callPlatformContentAI = async (platform, postContent) => {
  const currentYear = new Date().getFullYear();
  const prompt = `Generate a JSON object for a ${platform} post with keys "caption" and "hashtags".
  - caption: Rewrite the post for ${platform} tone, length, and style.
  - hashtags: 5-7 viral, platform-appropriate tags as an array. Prefer current/trending tags; if you include year-specific tags, use ${currentYear}.
  Only return JSON.

  Post Content: """${postContent}"""`;
  const response = await axios.post(chatApiUrl, {
    model: 'gpt-4o-mini',
    messages: [{ role: 'user', content: prompt }],
    response_format: { type: 'json_object' },
  }, { headers: { 'Authorization': `Bearer ${openaiApiKey}`, 'Content-Type': 'application/json' } });

  const result = JSON.parse(response.data.choices[0].message.content);
  const normalized = { caption: result.caption || postContent, hashtags: [] };
  const yearRegex = /(19|20)\d{2}/g;
  const targetYear = String(currentYear);
  const toList = (val) => Array.isArray(val) ? val : typeof val === 'string' ? val.split(',') : [];
  normalized.hashtags = toList(result.hashtags)
    .map(h => h?.toString()?.trim())
    .filter(Boolean)
    .map(h => h.startsWith('#') ? h : `#${h}`)
    .map(h => h.replace(yearRegex, targetYear))
    .map(h => h.replace(/\s+/g, ''));
  const uniqueSet = new Set();
  normalized.hashtags = normalized.hashtags.filter(h => {
    const key = h.toLowerCase();
    if (uniqueSet.has(key)) return false;
    uniqueSet.add(key);
    return true;
  });
  return normalized;
};


// =================================================================
// --- SPLIT API ENDPOINTS ---
// =================================================================
// Apply auth per-route so this router doesn't block unrelated /api/* paths

// Text-first endpoint: returns postContent, aiImagePrompt, and per-platform hashtags (no image generation)
router.post('/create-text-plan', authMiddleware, async (req, res) => {
  const { brief, platforms } = req.body;

  if (!brief || !platforms || !Array.isArray(platforms) || platforms.length === 0) {
    return res.status(400).json({ error: 'A brief and at least one platform are required.' });
  }

  try {
    // --- Step 1: Generate the main content and image prompt ONCE ---
    const mainContentPrompt = `
      Based on the following creative brief, generate a JSON object with two keys: "postContent" and "aiImagePrompt".
      The "postContent" should be a universally engaging caption suitable for multiple social media platforms.
      Creative Brief: "${brief}"
      Your final output must be only the JSON object.
    `;
    const mainContentResponse = await axios.post(chatApiUrl, {
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: mainContentPrompt }],
      response_format: { type: 'json_object' },
    }, { headers: { 'Authorization': `Bearer ${openaiApiKey}`, 'Content-Type': 'application/json' } });

    const { postContent, aiImagePrompt } = JSON.parse(mainContentResponse.data.choices[0].message.content);

    // --- Step 2: For each platform, generate tailored caption + hashtags ---
    const platformPromises = platforms.map(platform => callPlatformContentAI(platform, postContent));
    const platformResults = await Promise.all(platformPromises);

    // --- Step 3: Combine everything into the response (no image yet) ---
    const finalResponse = {
      postContent: postContent,
      aiImagePrompt,
      imageUrl: null,
      platforms: {},
    };

    platforms.forEach((platform, index) => {
      finalResponse.platforms[platform] = {
        caption: platformResults[index].caption,
        hashtags: platformResults[index].hashtags,
      };
    });

    res.status(200).json(finalResponse);

  } catch (error) {
    console.error('Error in text plan generation:', error);
    res.status(500).json({ error: 'Failed to generate text content.' });
  }
});

// Image generation endpoint: accepts aiImagePrompt and returns a hosted imageUrl
router.post('/generate-image', authMiddleware, async (req, res) => {
  const { aiImagePrompt } = req.body;
  if (!aiImagePrompt || typeof aiImagePrompt !== 'string') {
    return res.status(400).json({ error: 'aiImagePrompt is required.' });
  }
  try {
    const tempImageUrl = await callImageAI(aiImagePrompt);
    const finalImageUrl = await uploadImageToCloudinary(tempImageUrl);
    return res.status(200).json({ imageUrl: finalImageUrl });
  } catch (error) {
    console.error('Error generating image:', error);
    return res.status(500).json({ error: 'Failed to generate image.' });
  }
});

// Regenerate platform captions from a base postContent
router.post('/regenerate-captions', authMiddleware, async (req, res) => {
  const { postContent, platforms } = req.body || {};
  if (!postContent || !platforms || !Array.isArray(platforms) || platforms.length === 0) {
    return res.status(400).json({ error: 'postContent and platforms[] are required.' });
  }
  try {
    const results = await Promise.all(platforms.map(p => callPlatformContentAI(p, postContent)));
    const out = { platforms: {} };
    platforms.forEach((p, i) => {
      out.platforms[p] = { caption: results[i].caption, hashtags: results[i].hashtags };
    });
    return res.status(200).json(out);
  } catch (e) {
    console.error('Error regenerating captions:', e);
    return res.status(500).json({ error: 'Failed to regenerate captions.' });
  }
});

// Regenerate platform hashtags from either a base postContent or a provided caption per platform
router.post('/regenerate-hashtags', authMiddleware, async (req, res) => {
  const { postContent, platforms, caption } = req.body || {};
  if ((!postContent && !caption) || !platforms || !Array.isArray(platforms) || platforms.length === 0) {
    return res.status(400).json({ error: 'platforms[] and postContent or caption are required.' });
  }
  try {
    const baseText = caption || postContent;
    const results = await Promise.all(platforms.map((p) => callHashtagAI(p, baseText)));
    const out = { platforms: {} };
    platforms.forEach((p, i) => {
      out.platforms[p] = { hashtags: results[i].hashtags };
    });
    return res.status(200).json(out);
  } catch (e) {
    console.error('Error regenerating hashtags:', e);
    return res.status(500).json({ error: 'Failed to regenerate hashtags.' });
  }
});

// Backward-compatible endpoint: keeps old behavior (text + image together)
router.post('/create-content-plan', authMiddleware, async (req, res) => {
  const { brief, platforms } = req.body;

  if (!brief || !platforms || !Array.isArray(platforms) || platforms.length === 0) {
    return res.status(400).json({ error: 'A brief and at least one platform are required.' });
  }

  try {
    // --- Step 1: Generate the main content and image prompt ONCE ---
    const mainContentPrompt = `
      Based on the following creative brief, generate a JSON object with two keys: "postContent" and "aiImagePrompt".
      The "postContent" should be a universally engaging caption suitable for multiple social media platforms.
      Creative Brief: "${brief}"
      Your final output must be only the JSON object.
    `;
    const mainContentResponse = await axios.post(chatApiUrl, {
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: mainContentPrompt }],
      response_format: { type: 'json_object' },
    }, { headers: { 'Authorization': `Bearer ${openaiApiKey}`, 'Content-Type': 'application/json' } });

    const { postContent, aiImagePrompt } = JSON.parse(mainContentResponse.data.choices[0].message.content);

    // --- Step 2: Generate and upload the single image ONCE ---
    const tempImageUrl = await callImageAI(aiImagePrompt);
    const finalImageUrl = await uploadImageToCloudinary(tempImageUrl);

    // --- Step 3: Loop through platforms to get unique hashtags ---
    const hashtagPromises = platforms.map(platform => callHashtagAI(platform, postContent));
    const hashtagResults = await Promise.all(hashtagPromises);

    // --- Step 4: Combine everything into the final response ---
    const finalResponse = {
      postContent: postContent,
      imageUrl: finalImageUrl,
      platforms: {},
    };

    platforms.forEach((platform, index) => {
      finalResponse.platforms[platform] = {
        hashtags: hashtagResults[index].hashtags,
      };
    });

    res.status(200).json(finalResponse);

  } catch (error) {
    console.error('Error in the full content pipeline:', error);
    res.status(500).json({ error: 'Failed to generate content.' });
  }
});

module.exports = router;